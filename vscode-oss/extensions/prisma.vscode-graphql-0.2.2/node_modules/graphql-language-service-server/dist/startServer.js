"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _net = _interopRequireDefault(require("net"));

var _GraphQLWatchman = require("./GraphQLWatchman");

var _MessageProcessor = require("./MessageProcessor");

var _vscodeJsonrpc = require("vscode-jsonrpc");

var _vscodeLanguageserver = require("vscode-languageserver");

var _Logger = require("./Logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _default =
/*#__PURE__*/
function () {
  var _startServer = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(options) {
    var logger, reader, writer, port, socket, connection;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            logger = new _Logger.Logger();

            if (!(options && options.method)) {
              _context.next = 21;
              break;
            }

            _context.t0 = options.method;
            _context.next = _context.t0 === 'socket' ? 5 : _context.t0 === 'stream' ? 12 : _context.t0 === 'node' ? 15 : 15;
            break;

          case 5:
            if (options.port) {
              _context.next = 9;
              break;
            }

            process.stderr.write('--port is required to establish socket connection.');
            process.exit(1);
            return _context.abrupt("return");

          case 9:
            port = options.port;
            socket = _net["default"].createServer(function (client) {
              client.setEncoding('utf8');
              reader = new _vscodeJsonrpc.SocketMessageReader(client);
              writer = new _vscodeJsonrpc.SocketMessageWriter(client);
              client.on('end', function () {
                socket.close();
                process.exit(0);
              });
              var connection = (0, _vscodeJsonrpc.createMessageConnection)(reader, writer, logger);
              addHandlers(connection, options.configDir, logger);
              connection.listen();
            }).listen(port);
            return _context.abrupt("return");

          case 12:
            reader = new _vscodeJsonrpc.StreamMessageReader(process.stdin);
            writer = new _vscodeJsonrpc.StreamMessageWriter(process.stdout);
            return _context.abrupt("break", 18);

          case 15:
            reader = new _vscodeJsonrpc.IPCMessageReader(process);
            writer = new _vscodeJsonrpc.IPCMessageWriter(process);
            return _context.abrupt("break", 18);

          case 18:
            connection = (0, _vscodeJsonrpc.createMessageConnection)(reader, writer, logger);
            addHandlers(connection, options.configDir, logger);
            connection.listen();

          case 21:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  function startServer(_x) {
    return _startServer.apply(this, arguments);
  }

  return startServer;
}();

exports["default"] = _default;

function addHandlers(connection, configDir, logger) {
  var messageProcessor = new _MessageProcessor.MessageProcessor(logger, new _GraphQLWatchman.GraphQLWatchman());
  connection.onNotification(_vscodeLanguageserver.DidOpenTextDocumentNotification.type,
  /*#__PURE__*/
  function () {
    var _ref = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee2(params) {
      var diagnostics;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return messageProcessor.handleDidOpenOrSaveNotification(params);

            case 2:
              diagnostics = _context2.sent;

              if (diagnostics) {
                connection.sendNotification(_vscodeLanguageserver.PublishDiagnosticsNotification.type, diagnostics);
              }

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x2) {
      return _ref.apply(this, arguments);
    };
  }());
  connection.onNotification(_vscodeLanguageserver.DidSaveTextDocumentNotification.type,
  /*#__PURE__*/
  function () {
    var _ref2 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee3(params) {
      var diagnostics;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return messageProcessor.handleDidOpenOrSaveNotification(params);

            case 2:
              diagnostics = _context3.sent;

              if (diagnostics) {
                connection.sendNotification(_vscodeLanguageserver.PublishDiagnosticsNotification.type, diagnostics);
              }

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x3) {
      return _ref2.apply(this, arguments);
    };
  }());
  connection.onNotification(_vscodeLanguageserver.DidChangeTextDocumentNotification.type,
  /*#__PURE__*/
  function () {
    var _ref3 = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee4(params) {
      var diagnostics;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return messageProcessor.handleDidChangeNotification(params);

            case 2:
              diagnostics = _context4.sent;

              if (diagnostics) {
                connection.sendNotification(_vscodeLanguageserver.PublishDiagnosticsNotification.type, diagnostics);
              }

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x4) {
      return _ref3.apply(this, arguments);
    };
  }());
  connection.onNotification(_vscodeLanguageserver.DidCloseTextDocumentNotification.type, function (params) {
    return messageProcessor.handleDidCloseNotification(params);
  });
  connection.onRequest(_vscodeLanguageserver.ShutdownRequest.type, function () {
    return messageProcessor.handleShutdownRequest();
  });
  connection.onNotification(_vscodeLanguageserver.ExitNotification.type, function () {
    return messageProcessor.handleExitNotification();
  }); // Ignore cancel requests

  connection.onNotification('$/cancelRequest', function () {
    return {};
  });
  connection.onRequest(_vscodeLanguageserver.InitializeRequest.type, function (params, token) {
    return messageProcessor.handleInitializeRequest(params, token, configDir);
  });
  connection.onRequest(_vscodeLanguageserver.CompletionRequest.type, function (params) {
    return messageProcessor.handleCompletionRequest(params);
  });
  connection.onRequest(_vscodeLanguageserver.CompletionResolveRequest.type, function (item) {
    return item;
  });
  connection.onRequest(_vscodeLanguageserver.DefinitionRequest.type, function (params) {
    return messageProcessor.handleDefinitionRequest(params);
  });
  connection.onRequest(_vscodeLanguageserver.HoverRequest.type, function (params) {
    return messageProcessor.handleHoverRequest(params);
  });
  connection.onNotification(_vscodeLanguageserver.DidChangeWatchedFilesNotification.type, function (params) {
    return messageProcessor.handleWatchedFilesChangedNotification(params);
  });
}