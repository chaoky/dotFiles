"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGraphQLCache = getGraphQLCache;
exports.GraphQLCache = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _graphql = require("graphql");

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _graphqlConfig = require("graphql-config");

var _MessageProcessor = require("./MessageProcessor");

var _stringToHash = _interopRequireDefault(require("./stringToHash"));

var _glob = _interopRequireDefault(require("glob"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

// Maximum files to read when processing GraphQL files.
var MAX_READS = 200;
var DOCUMENT = _graphql.Kind.DOCUMENT,
    FRAGMENT_DEFINITION = _graphql.Kind.FRAGMENT_DEFINITION,
    OBJECT_TYPE_DEFINITION = _graphql.Kind.OBJECT_TYPE_DEFINITION,
    INTERFACE_TYPE_DEFINITION = _graphql.Kind.INTERFACE_TYPE_DEFINITION,
    ENUM_TYPE_DEFINITION = _graphql.Kind.ENUM_TYPE_DEFINITION,
    UNION_TYPE_DEFINITION = _graphql.Kind.UNION_TYPE_DEFINITION,
    SCALAR_TYPE_DEFINITION = _graphql.Kind.SCALAR_TYPE_DEFINITION,
    INPUT_OBJECT_TYPE_DEFINITION = _graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,
    SCALAR_TYPE_EXTENSION = _graphql.Kind.SCALAR_TYPE_EXTENSION,
    OBJECT_TYPE_EXTENSION = _graphql.Kind.OBJECT_TYPE_EXTENSION,
    INTERFACE_TYPE_EXTENSION = _graphql.Kind.INTERFACE_TYPE_EXTENSION,
    UNION_TYPE_EXTENSION = _graphql.Kind.UNION_TYPE_EXTENSION,
    ENUM_TYPE_EXTENSION = _graphql.Kind.ENUM_TYPE_EXTENSION,
    INPUT_OBJECT_TYPE_EXTENSION = _graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION,
    DIRECTIVE_DEFINITION = _graphql.Kind.DIRECTIVE_DEFINITION;

function getGraphQLCache(_x) {
  return _getGraphQLCache.apply(this, arguments);
}

function _getGraphQLCache() {
  _getGraphQLCache = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee15(configDir) {
    var graphQLConfig;
    return regeneratorRuntime.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            _context15.next = 2;
            return (0, _graphqlConfig.getGraphQLConfig)(configDir);

          case 2:
            graphQLConfig = _context15.sent;
            return _context15.abrupt("return", new GraphQLCache(configDir, graphQLConfig));

          case 4:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15);
  }));
  return _getGraphQLCache.apply(this, arguments);
}

var GraphQLCache =
/*#__PURE__*/
function () {
  function GraphQLCache(configDir, graphQLConfig) {
    var _this = this;

    _classCallCheck(this, GraphQLCache);

    _defineProperty(this, "_configDir", void 0);

    _defineProperty(this, "_graphQLFileListCache", void 0);

    _defineProperty(this, "_graphQLConfig", void 0);

    _defineProperty(this, "_cachePromise", void 0);

    _defineProperty(this, "_schemaMap", void 0);

    _defineProperty(this, "_typeExtensionMap", void 0);

    _defineProperty(this, "_fragmentDefinitionsCache", void 0);

    _defineProperty(this, "_typeDefinitionsCache", void 0);

    _defineProperty(this, "getGraphQLConfig", function () {
      return _this._graphQLConfig;
    });

    _defineProperty(this, "getFragmentDependencies",
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(query, fragmentDefinitions) {
        var parsedQuery;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (fragmentDefinitions) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", []);

              case 2:
                _context.prev = 2;
                parsedQuery = (0, _graphql.parse)(query, {
                  allowLegacySDLImplementsInterfaces: true,
                  allowLegacySDLEmptyFields: true
                });
                _context.next = 9;
                break;

              case 6:
                _context.prev = 6;
                _context.t0 = _context["catch"](2);
                return _context.abrupt("return", []);

              case 9:
                return _context.abrupt("return", _this.getFragmentDependenciesForAST(parsedQuery, fragmentDefinitions));

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[2, 6]]);
      }));

      return function (_x2, _x3) {
        return _ref.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getFragmentDependenciesForAST",
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(parsedQuery, fragmentDefinitions) {
        var existingFrags, referencedFragNames, asts, referencedFragments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (fragmentDefinitions) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", []);

              case 2:
                existingFrags = new Map();
                referencedFragNames = new Set();
                (0, _graphql.visit)(parsedQuery, {
                  FragmentDefinition: function FragmentDefinition(node) {
                    existingFrags.set(node.name.value, true);
                  },
                  FragmentSpread: function FragmentSpread(node) {
                    if (!referencedFragNames.has(node.name.value)) {
                      referencedFragNames.add(node.name.value);
                    }
                  }
                });
                asts = new Set();
                referencedFragNames.forEach(function (name) {
                  if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {
                    asts.add((0, _nullthrows["default"])(fragmentDefinitions.get(name)));
                  }
                });
                referencedFragments = [];
                asts.forEach(function (ast) {
                  (0, _graphql.visit)(ast.definition, {
                    FragmentSpread: function FragmentSpread(node) {
                      if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
                        asts.add((0, _nullthrows["default"])(fragmentDefinitions.get(node.name.value)));
                        referencedFragNames.add(node.name.value);
                      }
                    }
                  });

                  if (!existingFrags.has(ast.definition.name.value)) {
                    referencedFragments.push(ast);
                  }
                });
                return _context2.abrupt("return", referencedFragments);

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x4, _x5) {
        return _ref2.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getFragmentDefinitions",
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(projectConfig) {
        var rootDir, filesFromInputDirs, list, _ref4, fragmentDefinitions, graphQLFileMap;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // This function may be called from other classes.
                // If then, check the cache first.
                rootDir = projectConfig.configDir;

                if (!_this._fragmentDefinitionsCache.has(rootDir)) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return", _this._fragmentDefinitionsCache.get(rootDir) || new Map());

              case 3:
                _context3.next = 5;
                return _this._readFilesFromInputDirs(rootDir, projectConfig.includes);

              case 5:
                filesFromInputDirs = _context3.sent;
                list = filesFromInputDirs.filter(function (fileInfo) {
                  return projectConfig.includesFile(fileInfo.filePath);
                });
                _context3.next = 9;
                return _this.readAllGraphQLFiles(list);

              case 9:
                _ref4 = _context3.sent;
                fragmentDefinitions = _ref4.fragmentDefinitions;
                graphQLFileMap = _ref4.graphQLFileMap;

                _this._fragmentDefinitionsCache.set(rootDir, fragmentDefinitions);

                _this._graphQLFileListCache.set(rootDir, graphQLFileMap);

                return _context3.abrupt("return", fragmentDefinitions);

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x6) {
        return _ref3.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getObjectTypeDependencies",
    /*#__PURE__*/
    function () {
      var _ref5 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(query, objectTypeDefinitions) {
        var parsedQuery;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (objectTypeDefinitions) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", []);

              case 2:
                _context4.prev = 2;
                parsedQuery = (0, _graphql.parse)(query, {
                  allowLegacySDLImplementsInterfaces: true,
                  allowLegacySDLEmptyFields: true
                });
                _context4.next = 9;
                break;

              case 6:
                _context4.prev = 6;
                _context4.t0 = _context4["catch"](2);
                return _context4.abrupt("return", []);

              case 9:
                return _context4.abrupt("return", _this.getObjectTypeDependenciesForAST(parsedQuery, objectTypeDefinitions));

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[2, 6]]);
      }));

      return function (_x7, _x8) {
        return _ref5.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getObjectTypeDependenciesForAST",
    /*#__PURE__*/
    function () {
      var _ref6 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(parsedQuery, objectTypeDefinitions) {
        var existingObjectTypes, referencedObjectTypes, asts, referencedObjects;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (objectTypeDefinitions) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt("return", []);

              case 2:
                existingObjectTypes = new Map();
                referencedObjectTypes = new Set();
                (0, _graphql.visit)(parsedQuery, {
                  ObjectTypeDefinition: function ObjectTypeDefinition(node) {
                    existingObjectTypes.set(node.name.value, true);
                  },
                  InputObjectTypeDefinition: function InputObjectTypeDefinition(node) {
                    existingObjectTypes.set(node.name.value, true);
                  },
                  EnumTypeDefinition: function EnumTypeDefinition(node) {
                    existingObjectTypes.set(node.name.value, true);
                  },
                  NamedType: function NamedType(node) {
                    if (!referencedObjectTypes.has(node.name.value)) {
                      referencedObjectTypes.add(node.name.value);
                    }
                  }
                });
                asts = new Set();
                referencedObjectTypes.forEach(function (name) {
                  if (!existingObjectTypes.has(name) && objectTypeDefinitions.has(name)) {
                    asts.add((0, _nullthrows["default"])(objectTypeDefinitions.get(name)));
                  }
                });
                referencedObjects = [];
                asts.forEach(function (ast) {
                  (0, _graphql.visit)(ast.definition, {
                    NamedType: function NamedType(node) {
                      if (!referencedObjectTypes.has(node.name.value) && objectTypeDefinitions.get(node.name.value)) {
                        asts.add((0, _nullthrows["default"])(objectTypeDefinitions.get(node.name.value)));
                        referencedObjectTypes.add(node.name.value);
                      }
                    }
                  });

                  if (!existingObjectTypes.has(ast.definition.name.value)) {
                    referencedObjects.push(ast);
                  }
                });
                return _context5.abrupt("return", referencedObjects);

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      return function (_x9, _x10) {
        return _ref6.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getObjectTypeDefinitions",
    /*#__PURE__*/
    function () {
      var _ref7 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(projectConfig) {
        var rootDir, filesFromInputDirs, list, _ref8, objectTypeDefinitions, graphQLFileMap;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                // This function may be called from other classes.
                // If then, check the cache first.
                rootDir = projectConfig.configDir;

                if (!_this._typeDefinitionsCache.has(rootDir)) {
                  _context6.next = 3;
                  break;
                }

                return _context6.abrupt("return", _this._typeDefinitionsCache.get(rootDir) || new Map());

              case 3:
                _context6.next = 5;
                return _this._readFilesFromInputDirs(rootDir, projectConfig.includes);

              case 5:
                filesFromInputDirs = _context6.sent;
                list = filesFromInputDirs.filter(function (fileInfo) {
                  return projectConfig.includesFile(fileInfo.filePath);
                });
                _context6.next = 9;
                return _this.readAllGraphQLFiles(list);

              case 9:
                _ref8 = _context6.sent;
                objectTypeDefinitions = _ref8.objectTypeDefinitions;
                graphQLFileMap = _ref8.graphQLFileMap;

                _this._typeDefinitionsCache.set(rootDir, objectTypeDefinitions);

                _this._graphQLFileListCache.set(rootDir, graphQLFileMap);

                return _context6.abrupt("return", objectTypeDefinitions);

              case 15:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      return function (_x11) {
        return _ref7.apply(this, arguments);
      };
    }());

    _defineProperty(this, "handleWatchmanSubscribeEvent", function (rootDir, projectConfig) {
      return function (result) {
        if (result.files && result.files.length > 0) {
          var graphQLFileMap = _this._graphQLFileListCache.get(rootDir);

          if (!graphQLFileMap) {
            return;
          }

          result.files.forEach(
          /*#__PURE__*/
          function () {
            var _ref10 = _asyncToGenerator(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee7(_ref9) {
              var name, exists, size, mtime, filePath, existingFile, fileAndContent;
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      name = _ref9.name, exists = _ref9.exists, size = _ref9.size, mtime = _ref9.mtime;

                      if (projectConfig.includesFile(name)) {
                        _context7.next = 3;
                        break;
                      }

                      return _context7.abrupt("return");

                    case 3:
                      filePath = _path["default"].join(result.root, result.subscription, name); // In the event of watchman recrawl (is_fresh_instance),
                      // watchman subscription returns a full set of files within the
                      // watched directory. After pruning with input/excluded directories,
                      // the file could have been created/modified.
                      // Using the cached size/mtime information, only cache the file if
                      // the file doesn't exist or the file exists and one of or both
                      // size/mtime is different.

                      if (!(result.is_fresh_instance && exists)) {
                        _context7.next = 14;
                        break;
                      }

                      existingFile = graphQLFileMap.get(filePath); // Same size/mtime means the file stayed the same

                      if (!(existingFile && existingFile.size === size && existingFile.mtime === mtime)) {
                        _context7.next = 8;
                        break;
                      }

                      return _context7.abrupt("return");

                    case 8:
                      _context7.next = 10;
                      return _this.promiseToReadGraphQLFile(filePath);

                    case 10:
                      fileAndContent = _context7.sent;
                      graphQLFileMap.set(filePath, _objectSpread({}, fileAndContent, {
                        size: size,
                        mtime: mtime
                      })); // Otherwise, create/update the cache with the updated file and
                      // content, or delete the cache if (!exists)

                      _context7.next = 23;
                      break;

                    case 14:
                      if (!graphQLFileMap) {
                        _context7.next = 21;
                        break;
                      }

                      _context7.t0 = _this._graphQLFileListCache;
                      _context7.t1 = rootDir;
                      _context7.next = 19;
                      return _this._updateGraphQLFileListCache(graphQLFileMap, {
                        size: size,
                        mtime: mtime
                      }, filePath, exists);

                    case 19:
                      _context7.t2 = _context7.sent;

                      _context7.t0.set.call(_context7.t0, _context7.t1, _context7.t2);

                    case 21:
                      _this.updateFragmentDefinitionCache(rootDir, filePath, exists);

                      _this.updateObjectTypeDefinitionCache(rootDir, filePath, exists);

                    case 23:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7);
            }));

            return function (_x12) {
              return _ref10.apply(this, arguments);
            };
          }());
        }
      };
    });

    _defineProperty(this, "_readFilesFromInputDirs", function (rootDir, includes) {
      var pattern;

      if (includes.length === 0) {
        return Promise.resolve([]);
      } // See https://github.com/graphql/graphql-language-service/issues/221
      // for details on why special handling is required here for the
      // includes.length === 1 case.


      if (includes.length === 1) {
        pattern = includes[0];
      } else {
        pattern = "{".concat(includes.join(','), "}");
      }

      return new Promise(function (resolve, reject) {
        var globResult = new _glob["default"].Glob(pattern, {
          cwd: rootDir,
          stat: true,
          absolute: false,
          ignore: ['generated/relay', '**/__flow__/**', '**/__generated__/**', '**/__github__/**', '**/__mocks__/**', '**/node_modules/**', '**/__flowtests__/**']
        }, function (error, results) {
          if (error) {
            reject(error);
          }
        });
        globResult.on('end', function () {
          resolve(Object.keys(globResult.statCache).filter(function (filePath) {
            return _typeof(globResult.statCache[filePath]) === 'object';
          }).map(function (filePath) {
            return {
              filePath: filePath,
              mtime: Math.trunc(globResult.statCache[filePath].mtime.getTime() / 1000),
              size: globResult.statCache[filePath].size
            };
          }));
        });
      });
    });

    _defineProperty(this, "getSchema",
    /*#__PURE__*/
    function () {
      var _ref11 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(appName) {
        var queryHasExtensions,
            projectConfig,
            projectName,
            schemaPath,
            endpointInfo,
            schemaCacheKey,
            schema,
            endpoint,
            endpointName,
            customDirectives,
            directivesSDL,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                queryHasExtensions = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : false;
                projectConfig = _this._graphQLConfig.getProjectConfig(appName);

                if (projectConfig) {
                  _context8.next = 4;
                  break;
                }

                return _context8.abrupt("return", null);

              case 4:
                projectName = appName || 'undefinedName';
                schemaPath = projectConfig.schemaPath;
                endpointInfo = _this._getDefaultEndpoint(projectConfig);
                schemaCacheKey = null;
                schema = null;

                if (!endpointInfo) {
                  _context8.next = 23;
                  break;
                }

                endpoint = endpointInfo.endpoint, endpointName = endpointInfo.endpointName;
                schemaCacheKey = "".concat(endpointName, ":").concat(projectName); // Maybe use cache

                if (!_this._schemaMap.has(schemaCacheKey)) {
                  _context8.next = 15;
                  break;
                }

                schema = _this._schemaMap.get(schemaCacheKey);
                return _context8.abrupt("return", schema && queryHasExtensions ? _this._extendSchema(schema, schemaPath, schemaCacheKey) : schema);

              case 15:
                _context8.prev = 15;
                _context8.next = 18;
                return endpoint.resolveSchema();

              case 18:
                schema = _context8.sent;
                _context8.next = 23;
                break;

              case 21:
                _context8.prev = 21;
                _context8.t0 = _context8["catch"](15);

              case 23:
                if (!(!schema && schemaPath)) {
                  _context8.next = 29;
                  break;
                }

                schemaCacheKey = "".concat(schemaPath, ":").concat(projectName); // Maybe use cache

                if (!_this._schemaMap.has(schemaCacheKey)) {
                  _context8.next = 28;
                  break;
                }

                schema = _this._schemaMap.get(schemaCacheKey);
                return _context8.abrupt("return", schema && queryHasExtensions ? _this._extendSchema(schema, schemaPath, schemaCacheKey) : schema);

              case 28:
                // Read from disk
                schema = projectConfig.getSchema();

              case 29:
                customDirectives = projectConfig.extensions.customDirectives;

                if (customDirectives && schema) {
                  directivesSDL = customDirectives.join('\n\n');
                  schema = (0, _graphql.extendSchema)(schema, (0, _graphql.parse)(directivesSDL, {
                    allowLegacySDLImplementsInterfaces: true,
                    allowLegacySDLEmptyFields: true
                  }));
                }

                if (schema) {
                  _context8.next = 33;
                  break;
                }

                return _context8.abrupt("return", null);

              case 33:
                if (_this._graphQLFileListCache.has(_this._configDir)) {
                  schema = _this._extendSchema(schema, schemaPath, schemaCacheKey);
                }

                if (schemaCacheKey) {
                  _this._schemaMap.set(schemaCacheKey, schema);
                }

                return _context8.abrupt("return", schema);

              case 36:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, null, [[15, 21]]);
      }));

      return function (_x13) {
        return _ref11.apply(this, arguments);
      };
    }());

    _defineProperty(this, "readAllGraphQLFiles",
    /*#__PURE__*/
    function () {
      var _ref12 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(list) {
        var queue, responses, chunk, promises;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                queue = list.slice(); // copy

                responses = [];

              case 2:
                if (!queue.length) {
                  _context9.next = 9;
                  break;
                }

                chunk = queue.splice(0, MAX_READS);
                promises = chunk.map(function (fileInfo) {
                  return _this.promiseToReadGraphQLFile(fileInfo.filePath)["catch"](function (error) {
                    /**
                     * fs emits `EMFILE | ENFILE` error when there are too many
                     * open files - this can cause some fragment files not to be
                     * processed.  Solve this case by implementing a queue to save
                     * files failed to be processed because of `EMFILE` error,
                     * and await on Promises created with the next batch from the
                     * queue.
                     */
                    if (error.code === 'EMFILE' || error.code === 'ENFILE') {
                      queue.push(fileInfo);
                    }
                  }).then(function (response) {
                    return responses.push(_objectSpread({}, response, {
                      mtime: fileInfo.mtime,
                      size: fileInfo.size
                    }));
                  });
                });
                _context9.next = 7;
                return Promise.all(promises);

              case 7:
                _context9.next = 2;
                break;

              case 9:
                return _context9.abrupt("return", _this.processGraphQLFiles(responses));

              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      return function (_x14) {
        return _ref12.apply(this, arguments);
      };
    }());

    _defineProperty(this, "processGraphQLFiles", function (responses) {
      var objectTypeDefinitions = new Map();
      var fragmentDefinitions = new Map();
      var graphQLFileMap = new Map();
      responses.forEach(function (response) {
        var filePath = response.filePath,
            content = response.content,
            asts = response.asts,
            mtime = response.mtime,
            size = response.size;

        if (asts) {
          asts.forEach(function (ast) {
            ast.definitions.forEach(function (definition) {
              if (definition.kind === FRAGMENT_DEFINITION) {
                fragmentDefinitions.set(definition.name.value, {
                  filePath: filePath,
                  content: content,
                  definition: definition
                });
              }

              if (definition.kind === OBJECT_TYPE_DEFINITION || definition.kind === INPUT_OBJECT_TYPE_DEFINITION || definition.kind === ENUM_TYPE_DEFINITION) {
                objectTypeDefinitions.set(definition.name.value, {
                  filePath: filePath,
                  content: content,
                  definition: definition
                });
              }
            });
          });
        } // Relay the previous object whether or not ast exists.


        graphQLFileMap.set(filePath, {
          filePath: filePath,
          content: content,
          asts: asts,
          mtime: mtime,
          size: size
        });
      });
      return {
        objectTypeDefinitions: objectTypeDefinitions,
        fragmentDefinitions: fragmentDefinitions,
        graphQLFileMap: graphQLFileMap
      };
    });

    _defineProperty(this, "promiseToReadGraphQLFile", function (filePath) {
      return new Promise(function (resolve, reject) {
        return _fs["default"].readFile(filePath, 'utf8', function (error, content) {
          if (error) {
            reject(error);
            return;
          }

          var asts = [];
          var queries = [];

          if (content.trim().length !== 0) {
            try {
              queries = (0, _MessageProcessor.getQueryAndRange)(content, filePath);

              if (queries.length === 0) {
                // still resolve with an empty ast
                resolve({
                  filePath: filePath,
                  content: content,
                  asts: [],
                  queries: []
                });
                return;
              }

              queries.forEach(function (_ref13) {
                var query = _ref13.query;
                return asts.push((0, _graphql.parse)(query, {
                  allowLegacySDLImplementsInterfaces: true,
                  allowLegacySDLEmptyFields: true
                }));
              });
            } catch (_) {
              // If query has syntax errors, go ahead and still resolve
              // the filePath and the content, but leave ast empty.
              resolve({
                filePath: filePath,
                content: content,
                asts: [],
                queries: []
              });
              return;
            }
          }

          resolve({
            filePath: filePath,
            content: content,
            asts: asts,
            queries: queries
          });
        });
      });
    });

    this._configDir = configDir;
    this._graphQLConfig = graphQLConfig;
    this._graphQLFileListCache = new Map();
    this._schemaMap = new Map();
    this._fragmentDefinitionsCache = new Map();
    this._typeDefinitionsCache = new Map();
    this._typeExtensionMap = new Map();
  }

  _createClass(GraphQLCache, [{
    key: "_updateGraphQLFileListCache",
    value: function () {
      var _updateGraphQLFileListCache2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(graphQLFileMap, metrics, filePath, exists) {
        var fileAndContent, existingFile, graphQLFileInfo;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (!exists) {
                  _context10.next = 6;
                  break;
                }

                _context10.next = 3;
                return this.promiseToReadGraphQLFile(filePath);

              case 3:
                _context10.t0 = _context10.sent;
                _context10.next = 7;
                break;

              case 6:
                _context10.t0 = null;

              case 7:
                fileAndContent = _context10.t0;
                existingFile = graphQLFileMap.get(filePath); // 3 cases for the cache invalidation: create/modify/delete.
                // For create/modify, swap the existing entry if available;
                // otherwise, just push in the new entry created.
                // For delete, check `exists` and splice the file out.

                if (existingFile && !exists) {
                  graphQLFileMap["delete"](filePath);
                } else if (fileAndContent) {
                  graphQLFileInfo = _objectSpread({}, fileAndContent, metrics);
                  graphQLFileMap.set(filePath, graphQLFileInfo);
                }

                return _context10.abrupt("return", graphQLFileMap);

              case 11:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _updateGraphQLFileListCache(_x15, _x16, _x17, _x18) {
        return _updateGraphQLFileListCache2.apply(this, arguments);
      }

      return _updateGraphQLFileListCache;
    }()
  }, {
    key: "updateFragmentDefinition",
    value: function () {
      var _updateFragmentDefinition = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(rootDir, filePath, contents) {
        var cache, asts;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                cache = this._fragmentDefinitionsCache.get(rootDir);
                asts = contents.map(function (_ref14) {
                  var query = _ref14.query;

                  try {
                    return {
                      ast: (0, _graphql.parse)(query, {
                        allowLegacySDLImplementsInterfaces: true,
                        allowLegacySDLEmptyFields: true
                      }),
                      query: query
                    };
                  } catch (error) {
                    return {
                      ast: null,
                      query: query
                    };
                  }
                });

                if (cache) {
                  // first go through the fragment list to delete the ones from this file
                  cache.forEach(function (value, key) {
                    if (value.filePath === filePath) {
                      cache["delete"](key);
                    }
                  });
                  asts.forEach(function (_ref15) {
                    var ast = _ref15.ast,
                        query = _ref15.query;

                    if (!ast) {
                      return;
                    }

                    ast.definitions.forEach(function (definition) {
                      if (definition.kind === FRAGMENT_DEFINITION) {
                        cache.set(definition.name.value, {
                          filePath: filePath,
                          content: query,
                          definition: definition
                        });
                      }
                    });
                  });
                }

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function updateFragmentDefinition(_x19, _x20, _x21) {
        return _updateFragmentDefinition.apply(this, arguments);
      }

      return updateFragmentDefinition;
    }()
  }, {
    key: "updateFragmentDefinitionCache",
    value: function () {
      var _updateFragmentDefinitionCache = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(rootDir, filePath, exists) {
        var fileAndContent, cache;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (!exists) {
                  _context12.next = 6;
                  break;
                }

                _context12.next = 3;
                return this.promiseToReadGraphQLFile(filePath);

              case 3:
                _context12.t0 = _context12.sent;
                _context12.next = 7;
                break;

              case 6:
                _context12.t0 = null;

              case 7:
                fileAndContent = _context12.t0;

                // In the case of fragment definitions, the cache could just map the
                // definition name to the parsed ast, whether or not it existed
                // previously.
                // For delete, remove the entry from the set.
                if (!exists) {
                  cache = this._fragmentDefinitionsCache.get(rootDir);

                  if (cache) {
                    cache["delete"](filePath);
                  }
                } else if (fileAndContent && fileAndContent.queries) {
                  this.updateFragmentDefinition(rootDir, filePath, fileAndContent.queries);
                }

              case 9:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function updateFragmentDefinitionCache(_x22, _x23, _x24) {
        return _updateFragmentDefinitionCache.apply(this, arguments);
      }

      return updateFragmentDefinitionCache;
    }()
  }, {
    key: "updateObjectTypeDefinition",
    value: function () {
      var _updateObjectTypeDefinition = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee13(rootDir, filePath, contents) {
        var cache, asts;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                cache = this._typeDefinitionsCache.get(rootDir);
                asts = contents.map(function (_ref16) {
                  var query = _ref16.query;

                  try {
                    return {
                      ast: (0, _graphql.parse)(query, {
                        allowLegacySDLImplementsInterfaces: true,
                        allowLegacySDLEmptyFields: true
                      }),
                      query: query
                    };
                  } catch (error) {
                    return {
                      ast: null,
                      query: query
                    };
                  }
                });

                if (cache) {
                  // first go through the types list to delete the ones from this file
                  cache.forEach(function (value, key) {
                    if (value.filePath === filePath) {
                      cache["delete"](key);
                    }
                  });
                  asts.forEach(function (_ref17) {
                    var ast = _ref17.ast,
                        query = _ref17.query;

                    if (!ast) {
                      return;
                    }

                    ast.definitions.forEach(function (definition) {
                      if (definition.kind === OBJECT_TYPE_DEFINITION || definition.kind === INPUT_OBJECT_TYPE_DEFINITION || definition.kind === ENUM_TYPE_DEFINITION) {
                        cache.set(definition.name.value, {
                          filePath: filePath,
                          content: query,
                          definition: definition
                        });
                      }
                    });
                  });
                }

              case 3:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function updateObjectTypeDefinition(_x25, _x26, _x27) {
        return _updateObjectTypeDefinition.apply(this, arguments);
      }

      return updateObjectTypeDefinition;
    }()
  }, {
    key: "updateObjectTypeDefinitionCache",
    value: function () {
      var _updateObjectTypeDefinitionCache = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee14(rootDir, filePath, exists) {
        var fileAndContent, cache;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (!exists) {
                  _context14.next = 6;
                  break;
                }

                _context14.next = 3;
                return this.promiseToReadGraphQLFile(filePath);

              case 3:
                _context14.t0 = _context14.sent;
                _context14.next = 7;
                break;

              case 6:
                _context14.t0 = null;

              case 7:
                fileAndContent = _context14.t0;

                // In the case of type definitions, the cache could just map the
                // definition name to the parsed ast, whether or not it existed
                // previously.
                // For delete, remove the entry from the set.
                if (!exists) {
                  cache = this._typeDefinitionsCache.get(rootDir);

                  if (cache) {
                    cache["delete"](filePath);
                  }
                } else if (fileAndContent && fileAndContent.queries) {
                  this.updateObjectTypeDefinition(rootDir, filePath, fileAndContent.queries);
                }

              case 9:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function updateObjectTypeDefinitionCache(_x28, _x29, _x30) {
        return _updateObjectTypeDefinitionCache.apply(this, arguments);
      }

      return updateObjectTypeDefinitionCache;
    }()
  }, {
    key: "_extendSchema",
    value: function _extendSchema(schema, schemaPath, schemaCacheKey) {
      var graphQLFileMap = this._graphQLFileListCache.get(this._configDir);

      var typeExtensions = [];

      if (!graphQLFileMap) {
        return schema;
      }

      graphQLFileMap.forEach(function (_ref18) {
        var filePath = _ref18.filePath,
            asts = _ref18.asts;
        asts.forEach(function (ast) {
          if (filePath === schemaPath) {
            return;
          }

          ast.definitions.forEach(function (definition) {
            switch (definition.kind) {
              case OBJECT_TYPE_DEFINITION:
              case INTERFACE_TYPE_DEFINITION:
              case ENUM_TYPE_DEFINITION:
              case UNION_TYPE_DEFINITION:
              case SCALAR_TYPE_DEFINITION:
              case INPUT_OBJECT_TYPE_DEFINITION:
              case SCALAR_TYPE_EXTENSION:
              case OBJECT_TYPE_EXTENSION:
              case INTERFACE_TYPE_EXTENSION:
              case UNION_TYPE_EXTENSION:
              case ENUM_TYPE_EXTENSION:
              case INPUT_OBJECT_TYPE_EXTENSION:
              case DIRECTIVE_DEFINITION:
                typeExtensions.push(definition);
                break;
            }
          });
        });
      });

      if (schemaCacheKey) {
        var sorted = typeExtensions.sort(function (a, b) {
          var aName = a.definition ? a.definition.name.value : a.name.value;
          var bName = b.definition ? b.definition.name.value : b.name.value;
          return aName > bName ? 1 : -1;
        });
        var hash = (0, _stringToHash["default"])(JSON.stringify(sorted));

        if (this._typeExtensionMap.has(schemaCacheKey) && this._typeExtensionMap.get(schemaCacheKey) === hash) {
          return schema;
        }

        this._typeExtensionMap.set(schemaCacheKey, hash);
      }

      return (0, _graphql.extendSchema)(schema, {
        kind: DOCUMENT,
        definitions: typeExtensions
      });
    }
  }, {
    key: "_getDefaultEndpoint",
    value: function _getDefaultEndpoint(projectConfig) {
      // Jumping through hoops to get the default endpoint by name (needed for cache key)
      var endpointsExtension = projectConfig.endpointsExtension;

      if (!endpointsExtension) {
        return null;
      }

      var defaultRawEndpoint = endpointsExtension.getRawEndpoint();
      var rawEndpointsMap = endpointsExtension.getRawEndpointsMap();
      var endpointName = Object.keys(rawEndpointsMap).find(function (name) {
        return rawEndpointsMap[name] === defaultRawEndpoint;
      });

      if (!endpointName) {
        return null;
      }

      return {
        endpointName: endpointName,
        endpoint: endpointsExtension.getEndpoint(endpointName)
      };
    }
    /**
     * Given a list of GraphQL file metadata, read all files collected from watchman
     * and create fragmentDefinitions and GraphQL files cache.
     */

  }]);

  return GraphQLCache;
}();

exports.GraphQLCache = GraphQLCache;