"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQueryAndRange = getQueryAndRange;
exports.MessageProcessor = void 0;

var _graphqlLanguageServiceTypes = require("graphql-language-service-types");

var _path = require("path");

var _fs = require("fs");

var _url = require("url");

var _graphqlConfig = require("graphql-config");

var _graphqlLanguageServiceInterface = require("graphql-language-service-interface");

var _graphqlLanguageServiceUtils = require("graphql-language-service-utils");

var _vscodeJsonrpc = require("vscode-jsonrpc");

var _vscodeLanguageserver = require("vscode-languageserver");

var _GraphQLCache = require("./GraphQLCache");

var _findGraphQLTags = require("./findGraphQLTags");

var _Logger = require("./Logger");

var _GraphQLWatchman = require("./GraphQLWatchman");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MessageProcessor =
/*#__PURE__*/
function () {
  function MessageProcessor(logger, watchmanClient) {
    _classCallCheck(this, MessageProcessor);

    _defineProperty(this, "_graphQLCache", void 0);

    _defineProperty(this, "_languageService", void 0);

    _defineProperty(this, "_textDocumentCache", void 0);

    _defineProperty(this, "_watchmanClient", void 0);

    _defineProperty(this, "_isInitialized", void 0);

    _defineProperty(this, "_willShutdown", void 0);

    _defineProperty(this, "_logger", void 0);

    this._textDocumentCache = new Map();
    this._isInitialized = false;
    this._willShutdown = false;
    this._logger = logger;
    this._watchmanClient = watchmanClient;
  }

  _createClass(MessageProcessor, [{
    key: "handleInitializeRequest",
    value: function () {
      var _handleInitializeRequest = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(params, token, configDir) {
        var serverCapabilities, rootPath, config;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (params) {
                  _context.next = 2;
                  break;
                }

                throw new Error('`params` argument is required to initialize.');

              case 2:
                serverCapabilities = {
                  capabilities: {
                    completionProvider: {
                      resolveProvider: true
                    },
                    definitionProvider: true,
                    textDocumentSync: 1,
                    hoverProvider: true
                  }
                };
                rootPath = (0, _path.dirname)((0, _graphqlConfig.findGraphQLConfigFile)(configDir ? configDir.trim() : params.rootPath));

                if (rootPath) {
                  _context.next = 6;
                  break;
                }

                throw new Error('`--configDir` option or `rootPath` argument is required.');

              case 6:
                _context.next = 8;
                return (0, _GraphQLCache.getGraphQLCache)(rootPath);

              case 8:
                this._graphQLCache = _context.sent;
                config = (0, _graphqlConfig.getGraphQLConfig)(rootPath);

                if (this._watchmanClient) {
                  this._subcribeWatchman(config, this._watchmanClient);
                }

                this._languageService = new _graphqlLanguageServiceInterface.GraphQLLanguageService(this._graphQLCache);

                if (serverCapabilities) {
                  _context.next = 14;
                  break;
                }

                throw new Error('GraphQL Language Server is not initialized.');

              case 14:
                this._isInitialized = true;

                this._logger.log(JSON.stringify({
                  type: 'usage',
                  messageType: 'initialize'
                }));

                return _context.abrupt("return", serverCapabilities);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function handleInitializeRequest(_x, _x2, _x3) {
        return _handleInitializeRequest.apply(this, arguments);
      }

      return handleInitializeRequest;
    }() // Use watchman to subscribe to project file changes only if watchman is
    // installed. Otherwise, rely on LSP watched files did change events.

  }, {
    key: "_subcribeWatchman",
    value: function () {
      var _subcribeWatchman2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(config, watchmanClient) {
        var _this = this;

        var projectMap, projectConfigs;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (watchmanClient) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                _context2.prev = 2;
                _context2.next = 5;
                return watchmanClient.checkVersion();

              case 5:
                // Otherwise, subcribe watchman according to project config(s).
                projectMap = config.getProjects();
                projectConfigs = projectMap ? Object.values(projectMap) : []; // There can either be a single config or one or more project
                // configs, but not both.

                if (projectConfigs.length === 0) {
                  projectConfigs = [config.getProjectConfig()];
                } // For each project config, subscribe to the file changes and update the
                // cache accordingly.


                projectConfigs.forEach(function (projectConfig) {
                  watchmanClient.subscribe(projectConfig.configDir, _this._graphQLCache.handleWatchmanSubscribeEvent(config.configDir, projectConfig));
                });
                _context2.next = 18;
                break;

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](2);

                if (!(_context2.t0.code === 'ENOENT')) {
                  _context2.next = 17;
                  break;
                }

                this._watchmanClient = undefined;
                _context2.next = 18;
                break;

              case 17:
                throw _context2.t0;

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 11]]);
      }));

      function _subcribeWatchman(_x4, _x5) {
        return _subcribeWatchman2.apply(this, arguments);
      }

      return _subcribeWatchman;
    }()
  }, {
    key: "handleDidOpenOrSaveNotification",
    value: function () {
      var _handleDidOpenOrSaveNotification = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(params) {
        var _this2 = this;

        var textDocument, text, uri, diagnostics, contents, cachedDocument;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this._isInitialized) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", null);

              case 2:
                if (!(!params || !params.textDocument)) {
                  _context4.next = 4;
                  break;
                }

                throw new Error('`textDocument` argument is required.');

              case 4:
                textDocument = params.textDocument;
                text = textDocument.text, uri = textDocument.uri;
                diagnostics = [];
                contents = []; // Create/modify the cached entry if text is provided.
                // Otherwise, try searching the cache to perform diagnostics.

                if (text || text === '') {
                  // textDocument/didSave does not pass in the text content.
                  // Only run the below function if text is passed in.
                  contents = getQueryAndRange(text, uri);

                  this._invalidateCache(textDocument, uri, contents);
                } else {
                  cachedDocument = this._getCachedDocument(uri);

                  if (cachedDocument) {
                    contents = cachedDocument.contents;
                  }
                }

                _context4.next = 11;
                return Promise.all(contents.map(
                /*#__PURE__*/
                function () {
                  var _ref2 = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee3(_ref) {
                    var query, range, results;
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            query = _ref.query, range = _ref.range;
                            _context3.next = 3;
                            return _this2._languageService.getDiagnostics(query, uri, _this2._isRelayCompatMode(query) ? false : true);

                          case 3:
                            results = _context3.sent;

                            if (results && results.length > 0) {
                              diagnostics.push.apply(diagnostics, _toConsumableArray(processDiagnosticsMessage(results, query, range)));
                            }

                          case 5:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x7) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 11:
                this._logger.log(JSON.stringify({
                  type: 'usage',
                  messageType: 'textDocument/didOpen',
                  projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
                  fileName: uri
                }));

                return _context4.abrupt("return", {
                  uri: uri,
                  diagnostics: diagnostics
                });

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function handleDidOpenOrSaveNotification(_x6) {
        return _handleDidOpenOrSaveNotification.apply(this, arguments);
      }

      return handleDidOpenOrSaveNotification;
    }()
  }, {
    key: "handleDidChangeNotification",
    value: function () {
      var _handleDidChangeNotification = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(params) {
        var _this3 = this;

        var textDocument, contentChanges, contentChange, uri, contents, cachedDocument, diagnostics;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this._isInitialized) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return", null);

              case 2:
                if (!(!params || !params.textDocument || !params.contentChanges || !params.textDocument.uri)) {
                  _context6.next = 4;
                  break;
                }

                throw new Error('`textDocument`, `textDocument.uri`, and `contentChanges` arguments are required.');

              case 4:
                textDocument = params.textDocument;
                contentChanges = params.contentChanges;
                contentChange = contentChanges[contentChanges.length - 1]; // As `contentChanges` is an array and we just want the
                // latest update to the text, grab the last entry from the array.

                uri = textDocument.uri || params.uri; // If it's a .js file, try parsing the contents to see if GraphQL queries
                // exist. If not found, delete from the cache.

                contents = getQueryAndRange(contentChange.text, uri); // If it's a .graphql file, proceed normally and invalidate the cache.

                this._invalidateCache(textDocument, uri, contents);

                cachedDocument = this._getCachedDocument(uri);

                if (cachedDocument) {
                  _context6.next = 13;
                  break;
                }

                return _context6.abrupt("return", null);

              case 13:
                this._updateFragmentDefinition(uri, contents);

                this._updateObjectTypeDefinition(uri, contents); // Send the diagnostics onChange as well


                diagnostics = [];
                _context6.next = 18;
                return Promise.all(contents.map(
                /*#__PURE__*/
                function () {
                  var _ref4 = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee5(_ref3) {
                    var query, range, results;
                    return regeneratorRuntime.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            query = _ref3.query, range = _ref3.range;
                            _context5.next = 3;
                            return _this3._languageService.getDiagnostics(query, uri);

                          case 3:
                            results = _context5.sent;

                            if (results && results.length > 0) {
                              diagnostics.push.apply(diagnostics, _toConsumableArray(processDiagnosticsMessage(results, query, range)));
                            }

                          case 5:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function (_x9) {
                    return _ref4.apply(this, arguments);
                  };
                }()));

              case 18:
                this._logger.log(JSON.stringify({
                  type: 'usage',
                  messageType: 'textDocument/didChange',
                  projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
                  fileName: uri
                }));

                return _context6.abrupt("return", {
                  uri: uri,
                  diagnostics: diagnostics
                });

              case 20:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function handleDidChangeNotification(_x8) {
        return _handleDidChangeNotification.apply(this, arguments);
      }

      return handleDidChangeNotification;
    }()
  }, {
    key: "handleDidCloseNotification",
    value: function handleDidCloseNotification(params) {
      if (!this._isInitialized) {
        return;
      } // For every `textDocument/didClose` event, delete the cached entry.
      // This is to keep a low memory usage && switch the source of truth to
      // the file on disk.


      if (!params || !params.textDocument) {
        throw new Error('`textDocument` is required.');
      }

      var textDocument = params.textDocument;
      var uri = textDocument.uri;

      if (this._textDocumentCache.has(uri)) {
        this._textDocumentCache["delete"](uri);
      }

      this._logger.log(JSON.stringify({
        type: 'usage',
        messageType: 'textDocument/didClose',
        projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
        fileName: uri
      }));
    }
  }, {
    key: "handleShutdownRequest",
    value: function handleShutdownRequest() {
      this._willShutdown = true;
      return;
    }
  }, {
    key: "handleExitNotification",
    value: function handleExitNotification() {
      process.exit(this._willShutdown ? 0 : 1);
    }
  }, {
    key: "validateDocumentAndPosition",
    value: function validateDocumentAndPosition(params) {
      if (!params || !params.textDocument || !params.textDocument.uri || !params.position) {
        throw new Error('`textDocument`, `textDocument.uri`, and `position` arguments are required.');
      }
    }
  }, {
    key: "handleCompletionRequest",
    value: function () {
      var _handleCompletionRequest = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(params, token) {
        var textDocument, position, cachedDocument, found, query, range, result;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this._isInitialized) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return", []);

              case 2:
                this.validateDocumentAndPosition(params);
                textDocument = params.textDocument;
                position = params.position; // `textDocument/completion` event takes advantage of the fact that
                // `textDocument/didChange` event always fires before, which would have
                // updated the cache with the query text from the editor.
                // Treat the computed list always complete.

                cachedDocument = this._getCachedDocument(textDocument.uri);

                if (cachedDocument) {
                  _context7.next = 8;
                  break;
                }

                throw new Error('A cached document cannot be found.');

              case 8:
                found = cachedDocument.contents.find(function (content) {
                  var currentRange = content.range;

                  if (currentRange && currentRange.containsPosition(position)) {
                    return true;
                  }
                }); // If there is no GraphQL query in this file, return an empty result.

                if (found) {
                  _context7.next = 11;
                  break;
                }

                return _context7.abrupt("return", []);

              case 11:
                query = found.query, range = found.range;

                if (range) {
                  position.line -= range.start.line;
                }

                _context7.next = 15;
                return this._languageService.getAutocompleteSuggestions(query, position, textDocument.uri);

              case 15:
                result = _context7.sent;

                this._logger.log(JSON.stringify({
                  type: 'usage',
                  messageType: 'textDocument/completion',
                  projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(textDocument.uri),
                  fileName: textDocument.uri
                }));

                return _context7.abrupt("return", {
                  items: result,
                  isIncomplete: false
                });

              case 18:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function handleCompletionRequest(_x10, _x11) {
        return _handleCompletionRequest.apply(this, arguments);
      }

      return handleCompletionRequest;
    }()
  }, {
    key: "handleHoverRequest",
    value: function () {
      var _handleHoverRequest = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(params, token) {
        var textDocument, position, cachedDocument, found, query, range, result;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this._isInitialized) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return", []);

              case 2:
                this.validateDocumentAndPosition(params);
                textDocument = params.textDocument;
                position = params.position;
                cachedDocument = this._getCachedDocument(textDocument.uri);

                if (cachedDocument) {
                  _context8.next = 8;
                  break;
                }

                throw new Error('A cached document cannot be found.');

              case 8:
                found = cachedDocument.contents.find(function (content) {
                  var currentRange = content.range;

                  if (currentRange && currentRange.containsPosition(position)) {
                    return true;
                  }
                }); // If there is no GraphQL query in this file, return an empty result.

                if (found) {
                  _context8.next = 11;
                  break;
                }

                return _context8.abrupt("return", '');

              case 11:
                query = found.query, range = found.range;

                if (range) {
                  position.line -= range.start.line;
                }

                _context8.next = 15;
                return this._languageService.getHoverInformation(query, position, textDocument.uri);

              case 15:
                result = _context8.sent;
                return _context8.abrupt("return", {
                  contents: result
                });

              case 17:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function handleHoverRequest(_x12, _x13) {
        return _handleHoverRequest.apply(this, arguments);
      }

      return handleHoverRequest;
    }()
  }, {
    key: "handleWatchedFilesChangedNotification",
    value: function () {
      var _handleWatchedFilesChangedNotification = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(params) {
        var _this4 = this;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(!this._isInitialized || this._watchmanClient)) {
                  _context11.next = 2;
                  break;
                }

                return _context11.abrupt("return", null);

              case 2:
                return _context11.abrupt("return", Promise.all(params.changes.map(
                /*#__PURE__*/
                function () {
                  var _ref5 = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee10(change) {
                    var uri, text, contents, diagnostics;
                    return regeneratorRuntime.wrap(function _callee10$(_context10) {
                      while (1) {
                        switch (_context10.prev = _context10.next) {
                          case 0:
                            if (!(change.type === _graphqlLanguageServiceTypes.FileChangeTypeKind.Created || change.type === _graphqlLanguageServiceTypes.FileChangeTypeKind.Changed)) {
                              _context10.next = 14;
                              break;
                            }

                            uri = change.uri;
                            text = (0, _fs.readFileSync)(new _url.URL(uri).pathname).toString();
                            contents = getQueryAndRange(text, uri);

                            _this4._updateFragmentDefinition(uri, contents);

                            _this4._updateObjectTypeDefinition(uri, contents);

                            _context10.next = 8;
                            return Promise.all(contents.map(
                            /*#__PURE__*/
                            function () {
                              var _ref7 = _asyncToGenerator(
                              /*#__PURE__*/
                              regeneratorRuntime.mark(function _callee9(_ref6) {
                                var query, range, results;
                                return regeneratorRuntime.wrap(function _callee9$(_context9) {
                                  while (1) {
                                    switch (_context9.prev = _context9.next) {
                                      case 0:
                                        query = _ref6.query, range = _ref6.range;
                                        _context9.next = 3;
                                        return _this4._languageService.getDiagnostics(query, uri);

                                      case 3:
                                        results = _context9.sent;

                                        if (!(results && results.length > 0)) {
                                          _context9.next = 8;
                                          break;
                                        }

                                        return _context9.abrupt("return", processDiagnosticsMessage(results, query, range));

                                      case 8:
                                        return _context9.abrupt("return", []);

                                      case 9:
                                      case "end":
                                        return _context9.stop();
                                    }
                                  }
                                }, _callee9);
                              }));

                              return function (_x16) {
                                return _ref7.apply(this, arguments);
                              };
                            }()));

                          case 8:
                            _context10.t0 = function (left, right) {
                              return left.concat(right);
                            };

                            diagnostics = _context10.sent.reduce(_context10.t0);

                            _this4._logger.log(JSON.stringify({
                              type: 'usage',
                              messageType: 'workspace/didChangeWatchedFiles',
                              projectName: _this4._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
                              fileName: uri
                            }));

                            return _context10.abrupt("return", {
                              uri: uri,
                              diagnostics: diagnostics
                            });

                          case 14:
                            if (change.type === _graphqlLanguageServiceTypes.FileChangeTypeKind.Deleted) {
                              _this4._graphQLCache.updateFragmentDefinitionCache(_this4._graphQLCache.getGraphQLConfig().configDir, change.uri, false);

                              _this4._graphQLCache.updateObjectTypeDefinitionCache(_this4._graphQLCache.getGraphQLConfig().configDir, change.uri, false);
                            }

                          case 15:
                          case "end":
                            return _context10.stop();
                        }
                      }
                    }, _callee10);
                  }));

                  return function (_x15) {
                    return _ref5.apply(this, arguments);
                  };
                }())));

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function handleWatchedFilesChangedNotification(_x14) {
        return _handleWatchedFilesChangedNotification.apply(this, arguments);
      }

      return handleWatchedFilesChangedNotification;
    }()
  }, {
    key: "handleDefinitionRequest",
    value: function () {
      var _handleDefinitionRequest = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(params, token) {
        var textDocument, position, cachedDocument, found, query, range, result, formatted;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (this._isInitialized) {
                  _context12.next = 2;
                  break;
                }

                return _context12.abrupt("return", []);

              case 2:
                if (!(!params || !params.textDocument || !params.position)) {
                  _context12.next = 4;
                  break;
                }

                throw new Error('`textDocument` and `position` arguments are required.');

              case 4:
                textDocument = params.textDocument;
                position = params.position;
                cachedDocument = this._getCachedDocument(textDocument.uri);

                if (cachedDocument) {
                  _context12.next = 9;
                  break;
                }

                throw new Error("".concat(textDocument.uri, " is not available."));

              case 9:
                found = cachedDocument.contents.find(function (content) {
                  var currentRange = content.range;

                  if (currentRange && currentRange.containsPosition(position)) {
                    return true;
                  }
                }); // If there is no GraphQL query in this file, return an empty result.

                if (found) {
                  _context12.next = 12;
                  break;
                }

                return _context12.abrupt("return", []);

              case 12:
                query = found.query, range = found.range;

                if (range) {
                  position.line -= range.start.line;
                }

                _context12.next = 16;
                return this._languageService.getDefinition(query, position, textDocument.uri);

              case 16:
                result = _context12.sent;
                formatted = result ? result.definitions.map(function (res) {
                  var defRange = res.range;
                  return {
                    // TODO: fix this hack!
                    // URI is being misused all over this library - there's a link that
                    // defines how an URI should be structured:
                    // https://tools.ietf.org/html/rfc3986
                    // Remove the below hack once the usage of URI is sorted out in related
                    // libraries.
                    uri: res.path.indexOf('file://') === 0 ? res.path : "file://".concat(res.path),
                    range: defRange
                  };
                }) : [];

                this._logger.log(JSON.stringify({
                  type: 'usage',
                  messageType: 'textDocument/definition',
                  projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(textDocument.uri),
                  fileName: textDocument.uri
                }));

                return _context12.abrupt("return", formatted);

              case 20:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function handleDefinitionRequest(_x17, _x18) {
        return _handleDefinitionRequest.apply(this, arguments);
      }

      return handleDefinitionRequest;
    }()
  }, {
    key: "_isRelayCompatMode",
    value: function _isRelayCompatMode(query) {
      return query.indexOf('RelayCompat') !== -1 || query.indexOf('react-relay/compat') !== -1;
    }
  }, {
    key: "_updateFragmentDefinition",
    value: function () {
      var _updateFragmentDefinition2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee13(uri, contents) {
        var rootDir;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                rootDir = this._graphQLCache.getGraphQLConfig().configDir;
                _context13.next = 3;
                return this._graphQLCache.updateFragmentDefinition(rootDir, new _url.URL(uri).pathname, contents);

              case 3:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function _updateFragmentDefinition(_x19, _x20) {
        return _updateFragmentDefinition2.apply(this, arguments);
      }

      return _updateFragmentDefinition;
    }()
  }, {
    key: "_updateObjectTypeDefinition",
    value: function () {
      var _updateObjectTypeDefinition2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee14(uri, contents) {
        var rootDir;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                rootDir = this._graphQLCache.getGraphQLConfig().configDir;
                _context14.next = 3;
                return this._graphQLCache.updateObjectTypeDefinition(rootDir, new _url.URL(uri).pathname, contents);

              case 3:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function _updateObjectTypeDefinition(_x21, _x22) {
        return _updateObjectTypeDefinition2.apply(this, arguments);
      }

      return _updateObjectTypeDefinition;
    }()
  }, {
    key: "_getCachedDocument",
    value: function _getCachedDocument(uri) {
      if (this._textDocumentCache.has(uri)) {
        var cachedDocument = this._textDocumentCache.get(uri);

        if (cachedDocument) {
          return cachedDocument;
        }
      }

      return null;
    }
  }, {
    key: "_invalidateCache",
    value: function _invalidateCache(textDocument, uri, contents) {
      if (this._textDocumentCache.has(uri)) {
        var cachedDocument = this._textDocumentCache.get(uri);

        if (cachedDocument && cachedDocument.version < textDocument.version) {
          // Current server capabilities specify the full sync of the contents.
          // Therefore always overwrite the entire content.
          this._textDocumentCache.set(uri, {
            version: textDocument.version,
            contents: contents
          });
        }
      } else {
        this._textDocumentCache.set(uri, {
          version: textDocument.version,
          contents: contents
        });
      }
    }
  }]);

  return MessageProcessor;
}();
/**
 * Helper functions to perform requested services from client/server.
 */
// Check the uri to determine the file type (JavaScript/GraphQL).
// If .js file, either return the parsed query/range or null if GraphQL queries
// are not found.


exports.MessageProcessor = MessageProcessor;

function getQueryAndRange(text, uri) {
  // Check if the text content includes a GraphQLV query.
  // If the text doesn't include GraphQL queries, do not proceed.
  if ((0, _path.extname)(uri) === '.js') {
    if (text.indexOf('graphql`') === -1 && text.indexOf('graphql.experimental`') === -1 && text.indexOf('gql`') === -1) {
      return [];
    }

    var templates = (0, _findGraphQLTags.findGraphQLTags)(text);
    return templates.map(function (_ref8) {
      var template = _ref8.template,
          range = _ref8.range;
      return {
        query: template,
        range: range
      };
    });
  } else {
    var query = text;

    if (!query && query !== '') {
      return [];
    }

    var lines = query.split('\n');
    var range = new _graphqlLanguageServiceUtils.Range(new _graphqlLanguageServiceUtils.Position(0, 0), new _graphqlLanguageServiceUtils.Position(lines.length - 1, lines[lines.length - 1].length - 1));
    return [{
      query: query,
      range: range
    }];
  }
}

function processDiagnosticsMessage(results, query, range) {
  var queryLines = query.split('\n');
  var totalLines = queryLines.length;
  var lastLineLength = queryLines[totalLines - 1].length;
  var lastCharacterPosition = new _graphqlLanguageServiceUtils.Position(totalLines, lastLineLength);
  var processedResults = results.filter(function (diagnostic) {
    return diagnostic.range.end.lessThanOrEqualTo(lastCharacterPosition);
  });

  if (range) {
    var offset = range.start;
    return processedResults.map(function (diagnostic) {
      return _objectSpread({}, diagnostic, {
        range: new _graphqlLanguageServiceUtils.Range(new _graphqlLanguageServiceUtils.Position(diagnostic.range.start.line + offset.line, diagnostic.range.start.character), new _graphqlLanguageServiceUtils.Position(diagnostic.range.end.line + offset.line, diagnostic.range.end.character))
      });
    });
  }

  return processedResults;
}